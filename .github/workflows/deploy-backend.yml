name: Deploy Backend

on:
  push:
    branches: [main, develop]
    paths:
      - 'app/**'
      - 'tests/**'
      - 'alembic/**'
      - 'requirements*.txt'
      - 'template.yaml'
      - 'samconfig.toml'
      - '.github/workflows/deploy-backend.yml'
  pull_request:
    branches: [main]
    paths:
      - 'app/**'
      - 'tests/**'
      - 'alembic/**'
      - 'requirements*.txt'
      - 'template.yaml'
      - 'samconfig.toml'
      - '.github/workflows/deploy-backend.yml'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'dev'
        type: choice
        options:
          - dev
          - staging
          - prod

# Required for OIDC token exchange and repository tagging
permissions:
  id-token: write
  contents: write  # Required for creating and pushing tags

env:
  AWS_REGION: us-east-1
  PYTHON_VERSION: '3.12'

jobs:
  test:
    name: Run Tests
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Cache pip dependencies
        uses: actions/cache@v3
        with:
          path: |
            ~/.cache/pip
            ~/.local/lib/python${{ env.PYTHON_VERSION }}/site-packages
          key: ${{ runner.os }}-pip-${{ env.PYTHON_VERSION }}-${{ hashFiles('requirements-test.txt', 'requirements.txt') }}
          restore-keys: |
            ${{ runner.os }}-pip-${{ env.PYTHON_VERSION }}-
            ${{ runner.os }}-pip-

      - name: Install dependencies
        working-directory: .
        run: |
          python -m pip install --upgrade pip
          
          # Check if cache was restored
          if [ -d ~/.cache/pip ]; then
            echo "âœ… Pip cache restored successfully"
            echo "Cache size: $(du -sh ~/.cache/pip | cut -f1)"
          else
            echo "ðŸ“¦ Building fresh pip cache"
          fi
          
          pip install -r requirements-test.txt
          
          # Display installed packages for debugging
          echo "Installed packages:"
          pip list --format=columns

      - name: Run tests with coverage
        working-directory: .
        env:
          # Test environment variables (not used for actual connections, just to satisfy config validation)
          DATABASE_URL: "sqlite:///:memory:"
          SECRET_KEY: "test-secret-key-for-ci-only-not-for-production-use"
          ENVIRONMENT: "test"
        run: |
          echo "ðŸ§ª Running backend tests with coverage..."
          
          # Run tests using pytest configuration
          if python -m pytest -v --tb=short; then
            echo "âœ… All backend tests passed with required coverage"
          else
            echo "âŒ Backend tests failed"
            echo "ðŸ” Test failures detected - check the output above for details"
            
            # Add test failure summary
            echo "## âŒ Backend Tests Failed" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "Backend tests failed during execution. Check the test output above for specific failure details." >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Commit:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
            echo "**Workflow:** [${{ github.run_id }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})" >> $GITHUB_STEP_SUMMARY
            
            exit 1
          fi

      - name: Upload test results and coverage
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: backend-test-results-${{ github.run_number }}
          path: |
            coverage.xml
            htmlcov/
            .coverage
          retention-days: 30

      - name: Upload coverage to workflow summary
        if: always()
        working-directory: .
        run: |
          if [ -f coverage.xml ]; then
            echo "## ðŸ“Š Backend Test Coverage" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            
            # Extract coverage percentage from coverage.xml
            COVERAGE=$(python -c "
            import xml.etree.ElementTree as ET
            try:
                tree = ET.parse('coverage.xml')
                root = tree.getroot()
                coverage = root.attrib.get('line-rate', '0')
                print(f'{float(coverage)*100:.1f}%')
            except:
                print('Coverage data not available')
            ")
            
            echo "**Overall Coverage:** $COVERAGE" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "ðŸ“ Detailed coverage report available in artifacts" >> $GITHUB_STEP_SUMMARY
          fi

  build:
    name: Build Lambda Package
    runs-on: ubuntu-latest
    needs: test
    if: github.event_name != 'pull_request'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Set up AWS SAM CLI
        uses: aws-actions/setup-sam@v2
        with:
          use-installer: true

      - name: Cache SAM build artifacts
        uses: actions/cache@v3
        with:
          path: |
            .aws-sam/build
            .aws-sam/cache
          key: ${{ runner.os }}-sam-${{ env.PYTHON_VERSION }}-${{ hashFiles('template.yaml', 'requirements.txt', 'samconfig.toml') }}
          restore-keys: |
            ${{ runner.os }}-sam-${{ env.PYTHON_VERSION }}-
            ${{ runner.os }}-sam-

      - name: Build Lambda package
        working-directory: .
        run: |
          echo "ðŸ”¨ Building Lambda package..."
          
          # Check if SAM cache was restored
          if [ -d .aws-sam/build ]; then
            echo "âœ… SAM build cache restored"
            echo "Cache contents:"
            ls -la .aws-sam/build/ || true
          else
            echo "ðŸ“¦ Building fresh SAM artifacts"
          fi
          
          # Build with container for consistent environment
          if sam build --use-container --cached; then
            echo "âœ… SAM build completed successfully"
            echo "Build artifacts:"
            ls -la .aws-sam/build/
          else
            echo "âŒ SAM build failed"
            echo "ðŸ” Check the build output above for specific error details"
            
            # Add build failure summary
            echo "## âŒ Backend Build Failed" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "SAM build failed during Lambda package creation. Check the build output above for specific error details." >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Commit:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
            echo "**Workflow:** [${{ github.run_id }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})" >> $GITHUB_STEP_SUMMARY
            
            exit 1
          fi

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: sam-build-artifacts
          path: .aws-sam/build/

  determine-environment:
    name: Determine Deployment Environment
    runs-on: ubuntu-latest
    needs: [test, build]
    if: github.event_name != 'pull_request'
    
    outputs:
      environment: ${{ steps.env-logic.outputs.environment }}
      should-deploy: ${{ steps.env-logic.outputs.should-deploy }}
    
    steps:
      - name: Determine environment and deployment logic
        id: env-logic
        run: |
          # Environment determination logic
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            # Manual dispatch - use selected environment
            ENVIRONMENT="${{ inputs.environment }}"
            SHOULD_DEPLOY="true"
          elif [ "${{ github.event_name }}" = "push" ]; then
            # Automatic deployment based on branch
            case "${{ github.ref }}" in
              "refs/heads/main")
                ENVIRONMENT="prod"
                SHOULD_DEPLOY="true"
                ;;
              "refs/heads/develop")
                ENVIRONMENT="dev"
                SHOULD_DEPLOY="true"
                ;;
              "refs/heads/staging")
                ENVIRONMENT="staging"
                SHOULD_DEPLOY="true"
                ;;
              *)
                # Other branches - no deployment
                ENVIRONMENT="dev"
                SHOULD_DEPLOY="false"
                ;;
            esac
          else
            # Other events - no deployment
            ENVIRONMENT="dev"
            SHOULD_DEPLOY="false"
          fi
          
          echo "environment=$ENVIRONMENT" >> $GITHUB_OUTPUT
          echo "should-deploy=$SHOULD_DEPLOY" >> $GITHUB_OUTPUT
          echo "Determined environment: $ENVIRONMENT (deploy: $SHOULD_DEPLOY)"

  migrate:
    name: Run DB Migrations (${{ needs.determine-environment.outputs.environment }})
    runs-on: ubuntu-latest
    needs: [test, build, determine-environment]
    if: needs.determine-environment.outputs.should-deploy == 'true'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Install migration dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install alembic

      - name: Select database connection string
        id: db-url
        env:
          DEPLOY_ENV: ${{ needs.determine-environment.outputs.environment }}
        run: |
          case "$DEPLOY_ENV" in
            "prod")
              DB_URL="${{ secrets.DATABASE_URL_PROD }}"
              ;;
            *)
              DB_URL="${{ secrets.DATABASE_URL_DEV }}"
              ;;
          esac

          if [ -z "$DB_URL" ]; then
            echo "âŒ DATABASE_URL secret not set for environment: $DEPLOY_ENV"
            echo "Set DATABASE_URL_DEV or DATABASE_URL_PROD in GitHub repository secrets."
            exit 1
          fi

          echo "::add-mask::$DB_URL"
          echo "db_url=$DB_URL" >> $GITHUB_OUTPUT
          echo "âœ… Database URL resolved for $DEPLOY_ENV"

      - name: Check migration status
        id: check
        env:
          DATABASE_URL: ${{ steps.db-url.outputs.db_url }}
        run: |
          echo "ðŸ” Checking if database needs migrations..."

          CURRENT=$(alembic current 2>&1 | grep -oP '[a-f0-9]{12}' | head -1 || echo "none")
          HEAD=$(alembic heads 2>&1 | grep -oP '[a-f0-9]{12}' | head -1 || echo "none")

          echo "Current revision: $CURRENT"
          echo "Head revision:    $HEAD"

          if [ "$CURRENT" = "$HEAD" ] && [ "$CURRENT" != "none" ]; then
            echo "âœ… Database is up to date â€” no migrations needed"
            echo "needed=false" >> $GITHUB_OUTPUT
          else
            echo "âš ï¸ Pending migrations detected"
            echo "needed=true" >> $GITHUB_OUTPUT
          fi

      - name: Run alembic upgrade head
        if: steps.check.outputs.needed == 'true'
        env:
          DATABASE_URL: ${{ steps.db-url.outputs.db_url }}
        run: |
          echo "ðŸš€ Applying migrations..."
          if alembic upgrade head; then
            echo "âœ… Migrations applied successfully"
          else
            echo "âŒ Migration failed â€” aborting deployment"
            exit 1
          fi

      - name: Migration summary
        env:
          DEPLOY_ENV: ${{ needs.determine-environment.outputs.environment }}
          NEEDED: ${{ steps.check.outputs.needed }}
        run: |
          echo "## ðŸ—„ï¸ Database Migration ($DEPLOY_ENV)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          if [ "$NEEDED" = "true" ]; then
            echo "**Status:** âœ… Migrations applied" >> $GITHUB_STEP_SUMMARY
          else
            echo "**Status:** âœ… Already up to date â€” skipped" >> $GITHUB_STEP_SUMMARY
          fi
          echo "**Commit:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY

  deploy:
    name: Deploy to ${{ needs.determine-environment.outputs.environment }}
    runs-on: ubuntu-latest
    needs: [test, build, determine-environment, migrate]
    if: needs.determine-environment.outputs.should-deploy == 'true'
    
    environment: ${{ needs.determine-environment.outputs.environment }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up AWS SAM CLI
        uses: aws-actions/setup-sam@v2
        with:
          use-installer: true

      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: sam-build-artifacts
          path: .aws-sam/build/

      - name: Set environment-specific variables
        id: env-vars
        env:
          DEPLOY_ENV: ${{ needs.determine-environment.outputs.environment }}
        run: |
          # Set environment-specific AWS role ARNs and secret names
          case "$DEPLOY_ENV" in
            "dev")
              AWS_ROLE_ARN="${{ vars.AWS_ROLE_ARN_DEV || vars.AWS_ROLE_ARN }}"
              SECRET_NAME="${{ vars.SECRET_NAME_DEV || format('jewelry-manufacturing-{0}', 'dev') }}"
              ;;
            "staging")
              AWS_ROLE_ARN="${{ vars.AWS_ROLE_ARN_STAGING || vars.AWS_ROLE_ARN }}"
              SECRET_NAME="${{ vars.SECRET_NAME_STAGING || format('jewelry-manufacturing-{0}', 'staging') }}"
              ;;
            "prod")
              AWS_ROLE_ARN="${{ vars.AWS_ROLE_ARN_PROD || vars.AWS_ROLE_ARN }}"
              SECRET_NAME="${{ vars.SECRET_NAME_PROD || format('jewelry-manufacturing-{0}', 'prod') }}"
              ;;
            *)
              echo "Unknown environment: $DEPLOY_ENV"
              exit 1
              ;;
          esac
          
          echo "aws-role-arn=$AWS_ROLE_ARN" >> $GITHUB_OUTPUT
          echo "secret-name=$SECRET_NAME" >> $GITHUB_OUTPUT
          echo "Using AWS Role: $AWS_ROLE_ARN"
          echo "Using Secret: $SECRET_NAME"

      - name: Configure AWS credentials via OIDC
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ steps.env-vars.outputs.aws-role-arn }}
          aws-region: ${{ env.AWS_REGION }}
          role-session-name: GitHubActions-Backend-Deploy-${{ needs.determine-environment.outputs.environment }}

      - name: Retrieve secrets from AWS Secrets Manager
        id: secrets
        run: |
          SECRET_NAME="${{ steps.env-vars.outputs.secret-name }}"
          echo "Retrieving secrets from: $SECRET_NAME"
          
          # Get the secret value
          SECRET_JSON=$(aws secretsmanager get-secret-value \
            --secret-id "$SECRET_NAME" \
            --query SecretString \
            --output text)
          
          # Parse and set environment variables (masked for security)
          DATABASE_URL=$(echo "$SECRET_JSON" | jq -r .DATABASE_URL)
          JWT_SECRET_KEY=$(echo "$SECRET_JSON" | jq -r .JWT_SECRET_KEY)
          CORS_ORIGINS=$(echo "$SECRET_JSON" | jq -r .CORS_ORIGINS)
          
          # Set outputs (these will be masked in logs)
          echo "::add-mask::$DATABASE_URL"
          echo "::add-mask::$JWT_SECRET_KEY"
          echo "DATABASE_URL=$DATABASE_URL" >> $GITHUB_OUTPUT
          echo "JWT_SECRET_KEY=$JWT_SECRET_KEY" >> $GITHUB_OUTPUT
          echo "CORS_ORIGINS=$CORS_ORIGINS" >> $GITHUB_OUTPUT

      - name: Validate deployment prerequisites
        working-directory: .
        env:
          DEPLOY_ENV: ${{ needs.determine-environment.outputs.environment }}
        run: |
          echo "Validating deployment prerequisites for environment: $DEPLOY_ENV"
          
          # Check if required secrets are available
          if [ -z "${{ steps.secrets.outputs.DATABASE_URL }}" ]; then
            echo "ERROR: DATABASE_URL not found in secrets"
            exit 1
          fi
          
          if [ -z "${{ steps.secrets.outputs.JWT_SECRET_KEY }}" ]; then
            echo "ERROR: JWT_SECRET_KEY not found in secrets"
            exit 1
          fi
          
          # Validate environment-specific SAM config exists
          if [ ! -f "samconfig.toml" ]; then
            echo "ERROR: samconfig.toml not found"
            exit 1
          fi
          
          # Check if environment config exists in samconfig.toml
          if ! grep -q "^\[$DEPLOY_ENV\." samconfig.toml; then
            echo "WARNING: No specific config for $DEPLOY_ENV in samconfig.toml, using default"
          fi
          
          echo "Prerequisites validation passed"

      - name: Deploy to AWS Lambda
        working-directory: .
        env:
          DEPLOY_ENV: ${{ needs.determine-environment.outputs.environment }}
        run: |
          echo "ðŸš€ Starting deployment to environment: $DEPLOY_ENV"
          
          # Prepare parameter overrides, excluding empty values
          PARAM_OVERRIDES="DatabaseURL=${{ steps.secrets.outputs.DATABASE_URL }} SecretKey=${{ steps.secrets.outputs.JWT_SECRET_KEY }} Stage=$DEPLOY_ENV"
          
          # Only add AllowedOrigins if it's not empty
          CORS_ORIGINS="${{ steps.secrets.outputs.CORS_ORIGINS }}"
          if [ -n "$CORS_ORIGINS" ]; then
            PARAM_OVERRIDES="$PARAM_OVERRIDES AllowedOrigins=$CORS_ORIGINS"
          else
            # Use a default CORS origin for dev environment
            PARAM_OVERRIDES="$PARAM_OVERRIDES AllowedOrigins=http://localhost:5173,http://localhost:3000"
          fi
          
          echo "Deploying with parameters: DatabaseURL=***, SecretKey=***, Stage=$DEPLOY_ENV, AllowedOrigins=***"
          
          # Deploy using SAM with environment-specific configuration
          if sam deploy \
            --config-env "$DEPLOY_ENV" \
            --parameter-overrides $PARAM_OVERRIDES \
            --no-fail-on-empty-changeset \
            --no-confirm-changeset; then
            echo "âœ… SAM deployment completed successfully"
          else
            echo "âŒ SAM deployment failed"
            echo "ðŸ” Checking CloudFormation events for detailed error information..."
            
            # Get stack events for debugging
            STACK_NAME="jewelry-backend-$DEPLOY_ENV"
            aws cloudformation describe-stack-events \
              --stack-name "$STACK_NAME" \
              --max-items 10 \
              --query 'StackEvents[?ResourceStatus==`CREATE_FAILED` || ResourceStatus==`UPDATE_FAILED`].[Timestamp,ResourceType,ResourceStatus,ResourceStatusReason]' \
              --output table || echo "Could not retrieve stack events"
            
            exit 1
          fi

      - name: Get deployment outputs
        id: outputs
        env:
          DEPLOY_ENV: ${{ needs.determine-environment.outputs.environment }}
        run: |
          STACK_NAME="jewelry-backend-$DEPLOY_ENV"
          
          # Get API URL from CloudFormation outputs
          API_URL=$(aws cloudformation describe-stacks \
            --stack-name "$STACK_NAME" \
            --query 'Stacks[0].Outputs[?OutputKey==`ApiUrl`].OutputValue' \
            --output text)
          
          if [ -z "$API_URL" ] || [ "$API_URL" = "None" ]; then
            echo "ERROR: Failed to get API URL from CloudFormation stack"
            exit 1
          fi
          
          echo "API_URL=$API_URL" >> $GITHUB_OUTPUT
          echo "STACK_NAME=$STACK_NAME" >> $GITHUB_OUTPUT
          echo "Successfully retrieved API URL: $API_URL"

      - name: Validate deployment
        env:
          API_URL: ${{ steps.outputs.outputs.API_URL }}
        run: |
          echo "Validating deployment at: $API_URL"
          
          # Wait a moment for the API to be ready
          sleep 10
          
          # Test API health check
          HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$API_URL/docs" || echo "000")
          
          if [ "$HTTP_STATUS" = "200" ]; then
            echo "âœ… API is responding correctly (HTTP $HTTP_STATUS)"
          else
            echo "âš ï¸ API returned HTTP $HTTP_STATUS - this may be expected for some endpoints"
            echo "API URL: $API_URL"
          fi
          
          echo "Deployment validation completed"

      - name: Tag repository with deployment version
        id: tag-repo
        if: success()
        env:
          DEPLOY_ENV: ${{ needs.determine-environment.outputs.environment }}
          API_URL: ${{ steps.outputs.outputs.API_URL }}
          STACK_NAME: ${{ steps.outputs.outputs.STACK_NAME }}
        run: |
          # Generate version information
          TIMESTAMP=$(date +%Y%m%d-%H%M%S)
          SHORT_SHA=$(echo "${{ github.sha }}" | cut -c1-7)
          
          # Extract version from package.json or use semantic versioning pattern
          if [ -f "package.json" ]; then
            VERSION=$(node -p "require('./package.json').version" 2>/dev/null || echo "1.0.0")
          else
            # Generate semantic version based on commit count and date
            COMMIT_COUNT=$(git rev-list --count HEAD)
            DATE_VERSION=$(date +%Y.%m.%d)
            VERSION="v${DATE_VERSION}.${COMMIT_COUNT}"
          fi
          
          # Create deployment tag following the specified naming convention
          # Format: deploy-{component}-{environment}-{version}-{timestamp}
          TAG_NAME="deploy-backend-${DEPLOY_ENV}-${VERSION}-${TIMESTAMP}"
          
          # Configure git for tagging
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          
          # Create annotated tag with comprehensive deployment information
          TAG_MESSAGE="Backend deployment to ${DEPLOY_ENV}
          
          Deployment Details:
          - Environment: ${DEPLOY_ENV}
          - Version: ${VERSION}
          - Commit: ${{ github.sha }}
          - Timestamp: ${TIMESTAMP}
          - Stack: ${STACK_NAME}
          - API URL: ${API_URL}
          - Workflow: ${{ github.workflow }}
          - Run ID: ${{ github.run_id }}"
          
          git tag -a "$TAG_NAME" -m "$TAG_MESSAGE"
          
          # Push the tag to repository
          git push origin "$TAG_NAME"
          
          echo "âœ… Created deployment tag: $TAG_NAME"
          echo "TAG_NAME=$TAG_NAME" >> $GITHUB_OUTPUT
          
          # Add tag information to workflow summary
          echo "## ðŸ·ï¸ Deployment Tag Created" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Tag Name:** \`$TAG_NAME\`" >> $GITHUB_STEP_SUMMARY
          echo "**Version:** $VERSION" >> $GITHUB_STEP_SUMMARY
          echo "**Environment:** $DEPLOY_ENV" >> $GITHUB_STEP_SUMMARY
          echo "**Commit:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY

      - name: Cache statistics and cleanup
        if: always()
        run: |
          echo "## ðŸ“Š Cache Statistics" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # Pip cache statistics
          if [ -d ~/.cache/pip ]; then
            PIP_CACHE_SIZE=$(du -sh ~/.cache/pip | cut -f1)
            echo "**Pip Cache:** $PIP_CACHE_SIZE" >> $GITHUB_STEP_SUMMARY
          fi
          
          # SAM cache statistics
          if [ -d backend/.aws-sam ]; then
            SAM_CACHE_SIZE=$(du -sh backend/.aws-sam | cut -f1)
            echo "**SAM Cache:** $SAM_CACHE_SIZE" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY

      - name: Display deployment summary
        env:
          DEPLOY_ENV: ${{ needs.determine-environment.outputs.environment }}
        run: |
          echo "## ðŸš€ Backend Deployment Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Environment:** $DEPLOY_ENV" >> $GITHUB_STEP_SUMMARY
          echo "**Stack Name:** ${{ steps.outputs.outputs.STACK_NAME }}" >> $GITHUB_STEP_SUMMARY
          echo "**API URL:** ${{ steps.outputs.outputs.API_URL }}" >> $GITHUB_STEP_SUMMARY
          echo "**Commit:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "**Deployment Tag:** ${{ steps.tag-repo.outputs.TAG_NAME }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Next Steps" >> $GITHUB_STEP_SUMMARY
          echo "- Test API: [\`${{ steps.outputs.outputs.API_URL }}/docs\`](${{ steps.outputs.outputs.API_URL }}/docs)" >> $GITHUB_STEP_SUMMARY
          echo "- Frontend deployment will use this API URL automatically" >> $GITHUB_STEP_SUMMARY

      - name: Report deployment success
        if: success()
        env:
          DEPLOY_ENV: ${{ needs.determine-environment.outputs.environment }}
        run: |
          echo "âœ… Backend deployment to $DEPLOY_ENV completed successfully"
          echo "ðŸ”— API URL: ${{ steps.outputs.outputs.API_URL }}"
          echo "ðŸ·ï¸ Deployment Tag: ${{ steps.tag-repo.outputs.TAG_NAME }}"
          echo "ðŸ“Š Stack: ${{ steps.outputs.outputs.STACK_NAME }}"
          
          # Set workflow status for external monitoring
          echo "DEPLOYMENT_STATUS=success" >> $GITHUB_ENV
          echo "DEPLOYMENT_URL=${{ steps.outputs.outputs.API_URL }}" >> $GITHUB_ENV
          echo "DEPLOYMENT_ENVIRONMENT=$DEPLOY_ENV" >> $GITHUB_ENV

      - name: Report deployment failure
        if: failure()
        env:
          DEPLOY_ENV: ${{ needs.determine-environment.outputs.environment }}
        run: |
          echo "âŒ Backend deployment to $DEPLOY_ENV failed"
          echo "ðŸ” Check the workflow logs for detailed error information"
          echo "ðŸ“‹ Failed at step: ${{ job.status }}"
          echo "ðŸ”„ Commit: ${{ github.sha }}"
          
          # Add failure summary to workflow
          echo "## âŒ Backend Deployment Failed" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Environment:** $DEPLOY_ENV" >> $GITHUB_STEP_SUMMARY
          echo "**Commit:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "**Workflow Run:** [${{ github.run_id }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Troubleshooting" >> $GITHUB_STEP_SUMMARY
          echo "1. Check the workflow logs above for specific error messages" >> $GITHUB_STEP_SUMMARY
          echo "2. Verify AWS credentials and permissions" >> $GITHUB_STEP_SUMMARY
          echo "3. Check CloudFormation stack status in AWS console" >> $GITHUB_STEP_SUMMARY
          echo "4. Validate secrets in AWS Secrets Manager" >> $GITHUB_STEP_SUMMARY
          
          # Set workflow status for external monitoring
          echo "DEPLOYMENT_STATUS=failure" >> $GITHUB_ENV
          echo "DEPLOYMENT_ENVIRONMENT=$DEPLOY_ENV" >> $GITHUB_ENV
          
          exit 1

    outputs:
      api-url: ${{ steps.outputs.outputs.API_URL }}
      environment: ${{ needs.determine-environment.outputs.environment }}
      stack-name: ${{ steps.outputs.outputs.STACK_NAME }}
      deployment-tag: ${{ steps.tag-repo.outputs.TAG_NAME }}

  # Notification jobs for deployment events
  notify-deployment-started:
    name: Notify Deployment Started
    uses: ./.github/workflows/notify-deployment.yml
    needs: [determine-environment]
    if: needs.determine-environment.outputs.should-deploy == 'true'
    with:
      deployment_status: "started"
      deployment_environment: ${{ needs.determine-environment.outputs.environment }}
      deployment_component: "backend"
      commit_sha: ${{ github.sha }}
      workflow_run_id: ${{ github.run_id }}
    secrets:
      SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
      NOTIFICATION_EMAIL_API_KEY: ${{ secrets.NOTIFICATION_EMAIL_API_KEY }}
      NOTIFICATION_EMAIL_ENDPOINT: ${{ secrets.NOTIFICATION_EMAIL_ENDPOINT }}

  notify-deployment-success:
    name: Notify Deployment Success
    uses: ./.github/workflows/notify-deployment.yml
    needs: [deploy]
    if: success()
    with:
      deployment_status: "success"
      deployment_environment: ${{ needs.deploy.outputs.environment }}
      deployment_component: "backend"
      deployment_url: ${{ needs.deploy.outputs.api-url }}
      api_url: ${{ needs.deploy.outputs.api-url }}
      commit_sha: ${{ github.sha }}
      workflow_run_id: ${{ github.run_id }}
      deployment_tag: ${{ needs.deploy.outputs.deployment-tag }}
    secrets:
      SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
      NOTIFICATION_EMAIL_API_KEY: ${{ secrets.NOTIFICATION_EMAIL_API_KEY }}
      NOTIFICATION_EMAIL_ENDPOINT: ${{ secrets.NOTIFICATION_EMAIL_ENDPOINT }}

  notify-deployment-failure:
    name: Notify Deployment Failure
    uses: ./.github/workflows/notify-deployment.yml
    needs: [deploy, determine-environment]
    if: failure()
    with:
      deployment_status: "failure"
      deployment_environment: ${{ needs.determine-environment.outputs.environment }}
      deployment_component: "backend"
      commit_sha: ${{ github.sha }}
      workflow_run_id: ${{ github.run_id }}
      error_details: "Backend deployment failed. Check workflow logs for details."
    secrets:
      SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
      NOTIFICATION_EMAIL_API_KEY: ${{ secrets.NOTIFICATION_EMAIL_API_KEY }}
      NOTIFICATION_EMAIL_ENDPOINT: ${{ secrets.NOTIFICATION_EMAIL_ENDPOINT }}